options strict_smart_pointers = false
require DagorFiles
require ecs
require strings
require daslib/strings_boost
require daslib/ast_boost
require rtti
require ast
require EcsUtils
require fio
require uriparser
require daslib/lint

let MAX_LINE_LEN = 139

def uri_to_path(str : string)
  return str |> normalize_uri() |> uri_to_file_name()

def path_to_uri(str : string)
  return file_name_to_uri(str) |> normalize_uri()


def ends_with_separator(str : string)
  for c in "\\/"
    if ends_with(str, to_char(c))
      return true
  return false


def starts_with_separator(str : string)
  for c in "\\/"
    if starts_with(str, to_char(c))
      return true
  return false

def join_path(a, b : string)
  let res = build_string() <| $(builder)
    builder |> write(a)
    let ends = ends_with_separator(a)
    let starts = starts_with_separator(b)
    if ends && starts
      builder |> write(slice(b, 1))
    elif !ends && !starts
      builder |> write("/")
      builder |> write(b)
    else
      builder |> write(b)
  return fix_path(res)

def fix_path(path : string)
  return path |> path_to_uri() |> normalize_uri() |> uri_to_path()

def scan_dir(path : string; var res : table<string; void>; suffix = ".das")
  fio::dir(path) <| $(n)
    if n == "." || n == ".."
      return
    let f = path |> join_path(n)
    let fStat = stat(f)
    if !fStat.is_valid
      return
    if fStat.is_dir
      f |> scan_dir(res, suffix)
    elif fStat.is_reg && f |> ends_with(suffix)
      res |> insert(f)


struct EventData
  mod : string
  st : smart_ptr<ast::Structure>

typedef
  EventsData = table</*name*/string; EventData>
  SqEventsData = table<string; string>
  EnumsData = table<string; array<string>>

def get_annotation(var annotations : rtti::AnnotationList; tag : string) : smart_ptr<rtti::AnnotationDeclaration>
  for ann in annotations
    if ann.annotation.name == tag
      return ann
  return unsafe(reinterpret<smart_ptr<rtti::AnnotationDeclaration>> null)


def has_annotation(var annotations : rtti::AnnotationList; tag : string)
  let ann <- get_annotation(annotations, tag)
  return ann != null

def get_bool_argument(arguments : rtti::AnnotationArgumentList; tag : string; default_value = false)
  let arg = find_arg(arguments, tag)
  return arg ?as tBool ?? default_value

def get_argument(arguments : rtti::AnnotationArgumentList; tag : string; default_value = "")
  let arg = find_arg(arguments, tag)
  return arg ?as tString ?? default_value

def read_file(f)
  return build_string() <| $(str)
    var line = f |> df_gets(1024)
    while !empty(line)
      str |> write(line)
      line = f |> df_gets(1024)


def get_cpp_filter(filter_name : string; event_name : das_string) : string
  if filter_name == "target_entity_conn"
    return "(&rcptf::entity_ctrl_conn<{event_name}NetMsg, rcptf::TARGET_ENTITY>)"
  if filter_name == "entity_team"
    return "(&rcptf::entity_team<{event_name}NetMsg, rcptf::TARGET_ENTITY>)"
  if filter_name == "possessed_and_spectated"
    return "&rcptf::possessed_and_spectated"
  if filter_name == "possessed_and_spectated_player"
    return "&rcptf::possessed_and_spectated_player"
  return "&net::broadcast_rcptf"


def gen_cpp_event(cppEvents : EventsData; output, file_name : string; exclude_events : EventsData; cpp_events_include : array<string>; verbose : bool; check : bool = false)
  var process : array<tuple<fullName : string; mod : string; st : smart_ptr<ast::Structure>>>
  for eventName, eventData in keys(cppEvents), values(cppEvents)
    if exclude_events |> key_exists(eventName)
      continue
    process |> emplace <| [[auto eventName, eventData.mod, clone_to_move(eventData.st)]]
  process |> sort <| $(a, b)
    return a.fullName < b.fullName

  if length(process) == 0
    return
  var cppHeaderCont = ""
  let cppCont = build_string() <| $(cpp)
    cppHeaderCont = build_string() <| $(cppHeader)
      cpp |> write("// generated by dagor2/prog/scripts/genDasevents.das\r\n\r\n")
      cpp |> write("#include \"{file_name}.h\"\r\n")
      cpp |> write("#include <daECS/net/netEvent.h>\r\n")
      cpp |> write("#include <dasModules/aotEcsEvents.h>\r\n")
      cpp |> write("#include <dasModules/aotEcsEventsSq.h>\r\n")
      cpp |> write("#include <ecs/scripts/sqBindEvent.h>\r\n")
      cpp |> write("#include <bindQuirrelEx/autoBind.h>\r\n")
      for inc in cpp_events_include
        cpp |> write("#include {inc}\r\n\r\n")

      cppHeader |> write("// generated by dagor2/prog/scripts/genDasevents.das\r\n")
      cppHeader |> write("#pragma once\r\n\r\n")
      cppHeader |> write("#include <daECS/core/entityId.h>\r\n")
      cppHeader |> write("#include <daECS/core/event.h>\r\n")
      cppHeader |> write("#include <daECS/core/componentTypes.h>\r\n")
      cppHeader |> write("#include <math/dag_Point3.h>\r\n")
      cppHeader |> write("#include <util/dag_simpleString.h>\r\n")
      cppHeader |> write("#include <EASTL/string.h>\r\n\r\n")

      var prevMod = "____"
      for eventData in process
        if verbose
          print(" ++ {eventData.fullName}")
        var st & = eventData.st
        let ann <- st.annotations |> get_annotation("cpp_event")
        if ann != null
          let broadcast = ann.arguments |> get_bool_argument("broadcast")
          if prevMod != eventData.mod
            prevMod = eventData.mod
            cppHeader |> write("\r\n/// {eventData.mod}\r\n\r\n")
            cpp |> write("\r\n/// {eventData.mod}\r\n\r\n")
          cppHeader |> write(broadcast ? "ECS_BROADCAST_EVENT_TYPE(" : "ECS_UNICAST_EVENT_TYPE(")
          cppHeader |> write(st.name)
          var skip = 3
          var headerLineLen = 20
          for field in st.fields
            if --skip >= 0
              continue
            let foundCppType = get_underlying_ecs_type(field._type, true) <| $(typeName)
              let line = "/*{field.name}*/ {typeName == "ecs::string" ? "SimpleString" : typeName}"
              if headerLineLen + length(line) + 2 > MAX_LINE_LEN
                cppHeader |> write(",\\\r\n  ")
                headerLineLen = 0
              else
                cppHeader |> write(", ")
              headerLineLen += line |> length()
              cppHeader |> write(line)
            if !foundCppType
              cppHeader |> write("#error \"{field.name} has unknown cast type {describe(field._type)}\"\r\n")
              return
          cppHeader |> write(");\r\n")

          cpp |> write("ECS_REGISTER_EVENT({st.name});\r\n")
          let filter = ann.arguments |> get_argument("filter", "broadcast") |> get_cpp_filter(st.name)
          let routing = get_argument(ann.arguments, "routing")
          let reliability = get_argument(ann.arguments, "reliability", "RELIABLE_ORDERED")
          if !empty(routing)
            let ccast = broadcast ? "Broadcast" : "Unicast"
            let line = "ECS_REGISTER_NET_EVENT({st.name}, net::Er::{ccast}, net::{routing}, {filter}, {reliability});\r\n"
            if length(line) < MAX_LINE_LEN
              cpp |> write(line)
            else
              cpp |> write("ECS_REGISTER_NET_EVENT({st.name}, net::Er::{ccast}, net::{routing},\r\n  {filter}, {reliability});\r\n")

      cpp |> write("\r\nSQ_DEF_AUTO_BINDING_MODULE({file_name}, \"dasevents\")\r\n\{\r\n  Sqrat::Table tbl(vm);\r\n")
      for eventData in process
        let st & = eventData.st
        cpp |> write("  bind_dascript::DasEventsBind<{st.name}>::bind(vm, tbl);\r\n")
      cpp |> write("  return tbl;\r\n\}\r\n")

  let hFile = "{output}/{file_name}.h"
  let cppFile = "{output}/{file_name}.cpp"
  df_open(hFile, check ? DF_READ : DF_CREATE | DF_WRITE) <| $(cppHeader)
    if cppHeader == null
      print("[E] unable to open file '{hFile}'. Make sure that the folder '{output}' already exists")
      unsafe(fio::exit(1))
      return
    if check
      print("check {hFile}")
      if cppHeaderCont != read_file(cppHeader)
        print("[E] incorrect file contect '{hFile}'. Regenerate dasevents please (prog/genDasevents.bat)")
        unsafe(fio::exit(1))
    else
      print("write {hFile}")
      cppHeader |> df_puts(cppHeaderCont)

  df_open(cppFile, check ? DF_READ : DF_CREATE | DF_WRITE) <| $(cpp)
    if cpp == null
      print("[E] unable to open file '{cppFile}'. Make sure that the folder '{output}' already exists")
      unsafe(fio::exit(1))
      return
    if check
      print("check {cppFile}")
      if cppCont != read_file(cpp)
        print("[E] incorrect file contect '{hFile}'. Regenerate dasevents please (prog/genDasevents.bat)")
        unsafe(fio::exit(1))
    else
      print("write {cppFile}")
      cpp |> df_puts(cppCont)


def isSqIntType(typ)
  return (typ.baseType == Type tInt || typ.baseType == Type tInt8 || typ.baseType == Type tInt16
       || typ.baseType == Type tInt64 || typ.baseType == Type tUInt || typ.baseType == Type tUInt8
       || typ.baseType == Type tUInt16 || typ.baseType == Type tUInt64
       || typ.baseType == Type tEnumeration || typ.baseType == Type tEnumeration8 || typ.baseType == Type tEnumeration16
       || typ.baseType == Type tVariant || typ.baseType == Type tBitfield)

def get_sq_default_value(typ : smart_ptr<TypeDecl>; stub_name = "")
  if typ == null
    return "null"

  if typ.baseType == Type tBool
    return "false"
  if typ.baseType == Type tFloat || typ.baseType == Type tDouble
    return "0.0"
  if typ.baseType == Type tString
    return "\"\""
  if isSqIntType(typ)
    return "0"
  if typ.baseType == Type tHandle
    if typ.annotation.cppName == " ::ecs::EntityId"
      return "INVALID_ENTITY_ID"

  if typ.baseType == Type tStructure
    if !empty(stub_name)
      return stub_name

    error("unsupported type {describe(typ)}, add stub_res_type to quirrel_bind annotation with result type, stub_res_type=\"\\\{\\\}\" or stub_res_type=\"[]\" for example")
    panic("unsupported type")

  if typ.baseType == Type tTable
    return "\{\}"

  if typ.baseType == Type tArray
    return "[]"

  return "null"

def get_sq_type(typ : smart_ptr<TypeDecl>)
  if typ == null
    return "null"

  if typ.baseType == Type tBool
    return "bool"
  if typ.baseType == Type tFloat || typ.baseType == Type tDouble
    return "float"
  if typ.baseType == Type tString
    return "string"
  if isSqIntType(typ)
    return "integer"
  if typ.baseType == Type tHandle
    if typ.annotation.cppName == " ::ecs::EntityId"
      return "integer"

  if typ.baseType == Type tTable
    return "table"

  if typ.baseType == Type tArray
    return "array"

  return "instance" // float3, ecs::Object, etc


def get_func_stub(name : string; var fn : smart_ptr<Function>)
  var optionalArgsNum = 0
  let n = length(fn.arguments)
  var i = n
  while --i >= 0
    assume arg = fn.arguments[i]
    if arg._type.baseType != Type tPointer
      break
    if arg._type.firstType.baseType == Type tHandle && arg._type.firstType.annotation._module.name == "quirrel" && arg._type.firstType.annotation.name == "SQVM"
      continue
    optionalArgsNum += 1

  var stubResType = ""
  let quirrelBindAnn <- fn.annotations |> get_annotation("quirrel_bind")
  if quirrelBindAnn != null
    let stubResTypeArg = quirrelBindAnn.arguments |> find_arg("stub_res_type")
    stubResType = stubResTypeArg ?as tString ?? ""

  return build_string <| $(str)
    str |> write("function ")
    str |> write(name)
    str |> write("(")

    var first = true
    for arg, idx in fn.arguments, count()
      if (arg._type.baseType == Type tPointer && arg._type.firstType.baseType == Type tHandle
       && arg._type.firstType.annotation._module.name == "quirrel" && arg._type.firstType.annotation.name == "SQVM")
        continue
      if !first
        str |> write(", ")
      else
        first = false
      str |> write(arg.name)
      if idx >= n - optionalArgsNum
        str |> write(" = null")
    str |> write(")")
    str |> write("\{")
    for arg in fn.arguments
      if (arg._type.baseType == Type tPointer && arg._type.firstType.baseType == Type tHandle
       && arg._type.firstType.annotation._module.name == "quirrel" && arg._type.firstType.annotation.name == "SQVM")
        continue
      let sqType = get_sq_type(arg._type)
      str |> write("\r\n    assert(type(")
      str |> write(arg.name)
      str |> write(") == \"")
      str |> write(sqType)
      str |> write("\", @() $\"argument '")
      str |> write(arg.name)
      str |> write("' type error, expected '")
      str |> write(sqType)
      str |> write("', got '\{type(")
      str |> write(arg.name)
      str |> write(")\}'\") // ")
      str |> write(describe(arg._type))

    str |> write("\r\n    return ")
    str |> write(get_sq_default_value(fn.result, stubResType))
    str |> write(" // ")
    str |> write(describe(fn.result))
    str |> write("\r\n  \}")


def get_sq_stub(st : smart_ptr<Structure>; native_ctor : bool)
  return build_string <| $(str)
    str |> write(st.name)
    str |> write(" = class \{")

    var skip = 3
    var fieldsNum = 0
    var ctorFields = ""
    for field in st.fields
      if --skip >= 0
        continue
      fieldsNum += 1
      str |> write(" ")
      str |> write(field.name)
      str |> write(" = ")
      str |> write(get_sq_default_value(field._type))
      if native_ctor
        ctorFields += empty(ctorFields) ? "{field.name}" : ", {field.name}"
    if !native_ctor
      if fieldsNum == 0
        str |> write(" constructor() \{\}")
      else
        str |> write(" constructor(fields = null) \{")
        str |> write("\r\n    if (fields != null) \{")
        str |> write("\r\n      assert(type(fields) == \"table\")")
        str |> write("\r\n      foreach (name, val in fields) \{")
        var first = true
        skip = 3
        for fld in st.fields
          if --skip >= 0
            continue
          if first
            first = false
            str |> write("\r\n        if (name == \"")
          else
            str |> write("\r\n        else if (name == \"")
          str |> write(fld.name)
          str |> write("\") assert(type(val) == \"")
          str |> write(get_sq_type(fld._type))
          str |> write("\", @() $\"'")
          str |> write(fld.name)
          str |> write("' type error, expected '")
          str |> write(get_sq_type(fld._type))
          str |> write("', got '\{type(val)\}'\") // ")
          str |> write(describe(fld._type))
        str |> write("\r\n        else assert(false, @() $\"unknown field '\{name\}'\")")
        str |> write("\r\n      \}")
        str |> write("\r\n    \}")
        str |> write("\r\n  \}")
    else
      if fieldsNum == 0
        str |> write(" constructor({ctorFields}) \{\}")
      else
        str |> write(" constructor({ctorFields}) \{")
        skip = 3
        for field in st.fields
          if --skip >= 0
            continue
          str |> write("\r\n    assert(type(")
          str |> write(field.name)
          str |> write(") == \"")
          str |> write(get_sq_type(field._type))
          str |> write("\", @() $\"field '")
          str |> write(field.name)
          str |> write("' type error, expected '")
          str |> write(get_sq_type(field._type))
          str |> write("', got '\{type(")
          str |> write(field.name)
          str |> write(")\}'\") // ")
          str |> write(describe(field._type))

        str |> write("\r\n  \}")

    str |> write(" \}")


def module_name(mod : rtti::Module?)
  return mod != null ? "{mod.name}::" : ""


def get_sq_enum_stub(enm : smart_ptr<Enumeration>; var res : EnumsData)
  var data <- [{ for it in enm.list; "{it.name} = {describe(it.value)}"}]
  let longName = "{module_name(enm._module)}{enm.name}"
  res[longName] <- data


def gen_for_module(path : string; verbose : bool; common_paths : array<string>; var sqStubsList : SqEventsData; var sqEnums : EnumsData; var cppEvents, commonCppEvents : EventsData)
  print("compile {path}")

  var stat : DagorStat
  let statRes = df_stat(path, stat)
  if statRes < 0
    print("[E] {path} doesn't exists")
    unsafe(fio::exit(1))

  var access <- make_file_access("")

  var cp = CodeOfPolicies()
  cp.ignore_shared_modules = true
  cp.no_optimizations = true
  var mg = new [[ModuleGroup()]]
  compile_file(path, access, mg, cp) <| $(ok, program, error)
    if !ok
      print("[E] Failed to compile '{path} file\n{error}")
      unsafe(fio::exit(1))
      return

    simulate(program) <| $ [unused_argument(context)] (sok; context; serrors)
      if !sok
        print("[E] Failed to simulate '{path} file\n{serrors}")
        unsafe(fio::exit(1))
        return

      var progs : array<tuple<name : string; prog : smart_ptr<Program>>> = [(path, program)]

      find_loaded_das() <| $ [unused_argument(fname, ctx)] (fname, ctx, prog)
        if fname.ends_with("_events.das") || fname.ends_with("_quirrel.das")
          progs |> emplace((fname, prog))
        return false

      for it in progs
        assume prog = it.prog
        print("> process {it.name}")
        prog |> program_for_each_module <| $(mod)
          let modName = "{mod.name}"
          if modName == "ecs" || modName == "$" // skip builtin modules
            return
          mod |> for_each_structure <| $(st)
            if st == null
              return
            let fileName = string(st.at.fileInfo.name)
            var isCommon = false
            for cpath in common_paths
              if fileName |> find(cpath) >= 0
                isCommon = true
                break
            let longName = "{module_name(st._module)}{st.name}"
            if has_annotation(st.annotations, "event")
              if verbose
                print(" + {st.name}")
              sqStubsList.insert(longName, get_sq_stub(st, /*native_ctor*/false))
            else
              let ann <- st.annotations |> get_annotation("cpp_event")
              if ann != null
                if ann.arguments |> get_bool_argument("with_scheme")
                  if ann.arguments |> get_bool_argument("cpp_gen", true)
                    emplace((isCommon ? commonCppEvents : cppEvents), longName, [[EventData mod="{mod.name}", st := st]])
                  sqStubsList.insert(longName, get_sq_stub(st, /*native_ctor*/true))

          mod |> for_each_enumeration <| $(enm)
            if enm.annotations |> has_annotation("export_enum")
              if verbose
                print(" * {enm.name}")
              get_sq_enum_stub(enm, sqEnums)

  access := null
  unsafe
    delete mg

def bind_quirrel(dir : string; verbose : bool; var quirrelBindings : table<string; table<string; string>>)
  print(" bind quirrel... {dir}")

  var files : table<string; void>
  scan_dir(dir, files, "_quirrel.das")

  for path in keys(files)
    var stat : DagorStat
    let statRes = df_stat(path, stat)
    if statRes < 0
      print("[E] {path} doesn't exists")
      unsafe(fio::exit(1))

    var access <- make_file_access("")

    var cp = CodeOfPolicies()
    cp.ignore_shared_modules = true
    cp.no_optimizations = true
    var mg = new [[ModuleGroup()]]
    var fileNameParts <- path |> replace("\\", "/") |> split("/")
    compile_file(path, access, mg, cp) <| $(ok, program, error)
      if !ok
        print("[E] Failed to compile '{path} file\n{error}")
        unsafe(fio::exit(1))
        return

      program |> program_for_each_module <| $(mod)
        let modName = "{mod.name}"
        if modName == "ecs" || modName == "$" // skip builtin modules
          return
        mod |> for_each_function("") <| $(fn)
          let ann <- fn.annotations |> get_annotation("quirrel_bind")
          if ann != null
            let nameArg = ann.arguments |> find_arg("name")
            let moduleNameArg = ann.arguments |> find_arg("module_name")
            let bindName = nameArg is nothing ? string(fn.name) : nameArg as tString
            if verbose
              print(" @ {bindName} -> {fn.name}")
            unsafe
              quirrelBindings[moduleNameArg ?as tString ?? "dasbind"]["{fileNameParts |> back()}::{bindName}"] = get_func_stub(bindName, fn)

    access := null
    unsafe
      delete mg
    delete fileNameParts


def get_bool_arg(args : array<string>; name : string; def_val : bool) : bool
  let idx = find_index(args, name)
  return idx >= 0 && idx + 1 < length(args) ? int(args[idx + 1]) != 0 : def_val

def get_str_arg(args : array<string>; name : string; def_val : string) : string
  let idx = find_index(args, name)
  return idx >= 0 && idx + 1 < length(args) ? args[idx + 1] : def_val

[export]
def main()

  print("Legend:")
  print(" + <event name>")
  print(" ++ <cpp event name>")
  print(" * <enum name>")
  print(" @ <quirrel bind name>\n")

  let args <- get_command_line_arguments()

  let cppFolder = args |> get_str_arg("--cpp_out", "")
  let cppFile = args |> get_str_arg("--cpp_file", "")
  let gameScripts = args |> get_str_arg("--scripts_out", ".")
  let gameGlobals = args |> get_str_arg("--globals_out", ".")
  let noSqStubs = args |> has_value("--no_sq_stubs")
  let check = args |> has_value("--check")
  let verbose = args |> get_bool_arg("--verbose", !check)

  var cppEventsData : EventsData
  var commonCppEvents : EventsData

  var sqStubsData <- {{ "$::sendNetEvent" => "sendNetEvent = @(_eid, eventInstance, connectids = null) assert(type(eventInstance)==\"instance\" && [\"null\",\"array\"].contains(type(connectids)))";
                        "$::broadcastNetEvent" => "broadcastNetEvent = @(eventInstance, connectids = null) assert(type(eventInstance)==\"instance\" && [\"null\",\"array\"].contains(type(connectids)))" }}
  var quirrelBindings : table<string; table<string; string>>
  var sqEnumsData : EnumsData
  var cppEventsInclude : array<string>

  var commonPaths : array<string>
  for i in range(length(args) - 1)
    if args[i] == "--common_path"
      commonPaths |> push(args[i + 1])

  for i in range(length(args) - 1)
    if args[i] == "--module"
      gen_for_module(args[i + 1], verbose, commonPaths, sqStubsData, sqEnumsData, cppEventsData, commonCppEvents)
    elif args[i] == "--cpp_include"
      cppEventsInclude |> push(args[i + 1])
    elif args[i] == "--bind_quirrel"
      bind_quirrel(args[i + 1], verbose, quirrelBindings)

  if !noSqStubs
    if length(sqStubsData) > 0
      var sqStubsList : array<tuple<string; string>>
      for k, v in keys(sqStubsData), values(sqStubsData)
        sqStubsList |> emplace <| [[auto k, v]]
      sqStubsList |> sort <| $(a, b)
        return a._0 < b._0

      let daseventsCont = build_string() <| $(sqStabs)
        sqStabs |> write("// generated by dagor2/prog/scripts/genDasevents.das\r\n\r\n")
        sqStabs |> write("//-file:declared-never-used\r\n")
        sqStabs |> write("from \"ecs\" import INVALID_ENTITY_ID\r\n")
        sqStabs |> write("return \{\r\n")
        var prevModule = ""
        for stub in sqStubsList
          let mod = split(stub._0, "::")[0]
          if mod != prevModule && mod != "$"
            sqStabs |> write("\r\n  // ")
            sqStabs |> write(mod)
            sqStabs |> write("\r\n\r\n")
            prevModule = mod

          sqStabs |> write("  ")
          sqStabs |> write(stub._1)
          sqStabs |> write("\r\n")
        sqStabs |> write("\}")

      df_open("{gameScripts}/dasevents", check ? DF_READ : DF_CREATE | DF_WRITE) <| $(sqStabsFile)
        if sqStabsFile == null
          print("[E] unable to open file '{gameScripts}/dasevents'. Make sure that the folder '{gameScripts}' already exists")
          unsafe(fio::exit(1))
        if check
          print("check {gameScripts}/dasevents")
          let cont = read_file(sqStabsFile)
          if daseventsCont != cont
            print("[E] incorrect file contect '{gameScripts}/dasevents'. Regenerate dasevents please (prog/genDasevents.bat)")
            unsafe(fio::exit(1))
        else
          print("write {gameScripts}/dasevents")
          sqStabsFile |> df_puts(daseventsCont)

    if length(quirrelBindings) > 0
      for module_name, binds in keys(quirrelBindings), values(quirrelBindings)
        var sqStubsList : array<tuple<string; string>>
        for k, v in keys(binds), values(binds)
          sqStubsList |> emplace <| [[auto k, v]]
        sqStubsList |> sort <| $(a, b)
          return a._0 < b._0

        let daseventsCont = build_string() <| $(dasbindStabs)
          dasbindStabs |> write("// generated by dagor2/prog/scripts/genDasevents.das\r\n\r\n")
          dasbindStabs |> write("//-file:declared-never-used\r\n")
          dasbindStabs |> write("from \"ecs\" import INVALID_ENTITY_ID\r\n")
          dasbindStabs |> write("return \{\r\n")
          var prevModule = ""
          for stub in sqStubsList
            let mod = split(stub._0, "::")[0]
            if mod != prevModule && mod != "$"
              prevModule = mod
              dasbindStabs |> write("\r\n // ")
              dasbindStabs |> write(mod)
              dasbindStabs |> write("\r\n\r\n")
            dasbindStabs |> write("  ")
            dasbindStabs |> write(stub._1)
            dasbindStabs |> write("\r\n")
          dasbindStabs |> write("\}")

        df_open("{gameScripts}/{module_name}", check ? DF_READ : DF_CREATE | DF_WRITE) <| $(dasbindFile)
          if dasbindFile == null
            print("[E] unable to open file '{gameScripts}/{module_name}'. Make sure that the folder '{gameScripts}' already exists")
            unsafe(fio::exit(1))
          if check
            print("check {gameScripts}/{module_name}")
            let cont = read_file(dasbindFile)
            if daseventsCont != cont
              print("[E] incorrect file contect '{gameScripts}/{module_name}'. Regenerate dasevents please (prog/genDasevents.bat)")
              unsafe(fio::exit(1))
          else
            print("write {gameScripts}/{module_name}")
            dasbindFile |> df_puts(daseventsCont)

    if length(sqEnumsData) > 0
      var sqEnums : array<tuple<string; array<string>>>
      for k, v in keys(sqEnumsData), values(sqEnumsData)
        sqEnums |> emplace <| [[auto k, v]]
      sqEnums |> sort <| $(a, b)
        return a._0 < b._0

      let dasenumsCont = build_string() <| $(sqStabs)
        sqStabs |> write("// generated by dagor2/prog/scripts/genDasevents.das\r\n")
        sqStabs |> write("//-file:declared-never-used\r\n")
        for stub in sqEnums
          sqStabs |> write("enum ")
          let names <- split(stub._0, "::")
          sqStabs |> write(names[length(names) - 1])
          sqStabs |> write(" \{  // ")
          sqStabs |> write(stub._0)
          sqStabs |> write("\r\n")

          for it in stub._1
            sqStabs |> write("  ")
            sqStabs |> write(it)
            sqStabs |> write("\r\n")

          sqStabs |> write("\}\r\nlet ")

          sqStabs |> write(names[length(names) - 1])
          sqStabs |> write("_COUNT = ")
          sqStabs |> write(length(stub._1))
          sqStabs |> write("\r\n\r\n")

        sqStabs |> write("return \{\r\n")
        for stub in sqEnums
          sqStabs |> write("  ")
          let names <- split(stub._0, "::")
          sqStabs |> write(names[length(names) - 1])
          sqStabs |> write("\r\n  ")
          sqStabs |> write(names[length(names) - 1])
          sqStabs |> write("_COUNT\r\n")

        sqStabs |> write("\}")

      df_open("{gameGlobals}/dasenums.nut", check ? DF_READ : DF_CREATE | DF_WRITE) <| $(sqStabs)
        if sqStabs == null
          print("[E] unable to open file '{gameGlobals}/dasenums.nut'. Make sure that the folder '{gameGlobals}' already exists")
          unsafe(fio::exit(1))
        if check
          print("check {gameGlobals}/dasenums.nut")
          if dasenumsCont != read_file(sqStabs)
            print("[E] incorrect file contect '{gameScripts}/dasenums.nut'. Regenerate dasevents please (prog/genDasevents.bat)")
            unsafe(fio::exit(1))
        else
          print("write {gameGlobals}/dasenums.nut")
          sqStabs |> df_puts(dasenumsCont)

  gen_cpp_event(cppEventsData, cppFolder, cppFile, commonCppEvents, cppEventsInclude, verbose, check)
